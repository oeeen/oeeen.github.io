---
layout: single
title:  "TIL(1월)"
date:   2020-01-01 12:00:59 +0900
classes: wide
categories: etc
tags: web
---

**틀린 내용이나 본문의 내용과 다른 의견이 있으시면 댓글로 남겨주세요!**

## 01/02

## Java에서 Exception에 관하여

1. Exception은 개발자가 구현한 로직에서 발생한다. 예외는 발생할 상황을 미리 예측해서 처리할 수 있다. 예외는 개발자가 처리 할 수 있기 때문에, 예외를 구분하고 그에 따른 처리 방법을 명확히 알고 적용하는 것이 중요하다.
2. Exception은 개발자가 로직을 추가하여 처리할 수 있다.
3. Exception은 많은 자식 클래스를 가지고 있다.
4. RuntimeException은 CheckedException과 UncheckedException을 구분하는 기준이다. RuntimeException을 제외한 모든 Exception의 자식 클래스는 CheckedException이고 RuntimeException과 그의 자식 클래스들은 모두 UncheckedException이다.

CheckedException => RuntimeException을 제외한 모든 Exception => 반드시 처리해 주어야 함(메서드 밖으로 throw하거나 catch 해줘야함)

### Checked Exception

- 반드시 예외를 처리해야 함
- 컴파일 단계에서 확인(CompileTime Exception)
- Roll-back 하지 않는다(Transaction 처리)
- Runtime Exception을 제외한 모든 예외

### Unchecked Exception

- 반드시 처리하지 않아도 됨.
- 실행 단계에서 확인(Runtime Exception)
- Roll-back
- ex) NullPointerException, IllegalArgumentException, IndexOutOfBoundException, SystemException 등

Unchecked Exception, Checked Exception을 사용할 것인지 결정하는 가장 기본적인 규칙은 **호출하는 쪽에서 복구, 대처할 수 있다면 Checked Exception**을 던진다. 아닐 경우에는 Unchecked Exception을 던진다.

그러면 Checked Exception은 언제 써야할까? 예외 복구 전략이 명확하고, 가능한 방법이라면 checked exception을 던지고 try-catch 에서 마땅한 복구를 해야한다.

SQLException은 CheckedException이지만 대부분의 경우에는 복구할 방법이 없다.(SQL 문법이 틀렸거나, DB Connection을 가져올 수 없거나.) 그렇기 때문에 이를 잡아서 unchecked exception으로 바꾸고 예외에 대한 메세지를 명확하게 전달해야한다. Spring에서 사용하는 JdbcTemplate에서도 SQLException을 잡아서 uncheckedException인 DataAccessException 으로 전환해서 던진다.

그러면 Checked Exception vs. Unchecked Exception 은?

가장 큰 차이는 예외를 명시적으로 처리 해주어야 하냐, 아니냐의 차이이다. 그리고 잘은 모르지만 예외 발생 시 트랜잭션을 roll-back 하느냐, 안하느냐 의 차이도 있다.

내 경우엔 CustomException은 모두 RuntimeException을 상속받아서 만들었는데, 이유는 Custom으로 만든 예외들은 모두 내가 예측 가능한 상황(유저가 패스워드를 틀리거나, DB에 없는 유저로 로그인을 하려고 한다거나..)에 대한 예외이기 때문에, 이 예외에 대한 처리를 할 필요가 없고 복구할 필요가 없기 때문에 unchecked exception으로 던졌다. Custom Exception을 던지면서 시스템 적으로 어떤 요청이 들어왔는지 로그로 남겨놓을 때 명시적으로 어떤 문제 때문에 발생했는지 표현하기 위해서 만들었다.

**Checked Exception은 트랜잭션 roll-back하지 않는다**는 것을 알아두어야 실수하지 않을 수 있다.

Checked Exception은 꼭 필요한 곳에서만 사용하면 프로그램의 안전성을 높여주지만, 남용한다면 그 메서드를 사용하는 쪽에서 try-catch가 사용되어야 하고, stream에서 사용할 수 없는 불편한 메서드가 많아진다. API 호출자가 예외 상황에서 복구할 방법이 없다면 unchecked exception을 던지는 편이 낫다. 복구가 가능하고 caller가 그 처리를 해주기를 바란다면 optional로 해결이 가능할 지 고민해보자.

### 참고 자료(Exception)

- [http://wonwoo.ml/index.php/post/878](http://wonwoo.ml/index.php/post/878)
- [https://cheese10yun.github.io/checked-exception/](https://cheese10yun.github.io/checked-exception/)
- Effective Java 3/e

## Javascript 기초

let은 block scope를 지원한다.

```html
<ul>
    <li>Java</li>
    <li>Javascript</li>
    <li>Spring</li>
    <li>Vue</li>
</ul>
```

이런 html이 있다고 생각해보고, 이 리스트에 event를 걸어준다고 해보자. 사실 보통은 다른 방식으로 하지만 하나하나 list요소들에 이벤트를 넣어줄 수도 있으니..

```javascript
var list = document.querySelectorAll("li");
for (var i = 0; i < list.length; i++) {
    list[i].addEventListener("click", function() {
        console.log(i + "번째 요소입니다.");
    });
}
```

위와 같은 방식으로 구현한 후 리스트 요소들을 눌러보면, 어떤 리스트 요소들을 누르더라도 4번째 요소라고 나오게 된다.

- closure란?

```javascript
function outter() {
    var title = 'coding everybody';
    return function() {
        alert(title);
    }
}
var inner = outter();
inner();
```

outter() 라는 함수는 실행이 끝나고 inner라는 함수가 실행할 때, outter() 함수에서의 변수에 대한 접근을 할 수 있다.. 이게 closure의 중요한 특징이다.

```javascript
function factory_movie(title) {
    return {
        get_title: function() {
            return title;
        },
        set_title: function(_title) {
            title = _title;
        }
    }
}
ghost = factory_movie('Ghost in the shell');
matrix = factory_movie('Matrix');
alert(ghost.get_title()); // Ghost in the shell
alert(matrix.get_title()); // Matrix
ghost.set_title('공각기동대');

alert(ghost.get_title()); // 공각기동대
alert(matrix.get_title()); // Matrix
```

ghost 와 matrix는 같은 객체이지만 그 객체안에 들어있는 get_title이 접근하는 외부 함수의 title이라는 값이 다르다.

factory_movie라는 메서드의 title이라는 변수는 factory_movie가 return 하면서 직접 접근할 수 없어지지만, 그 내부의 get_title, set_title이라는 메서드로만 접근 가능해진다.

```javascript
var arr = []
for (var i = 0; i < 5; i++) {
    arr[i] = function() {
        return i;
    }
}
for (var i in arr) {
    console.log(arr[i]());
}
```

이 경우엔 원하는 대로 동작하지 않는다. 이를 closure의 특성을 생각하여 변경하면 원하는 대로 동작한다(1~4 출력)

```javascript
var arr = []
for (var i = 0; i < 5; i++) {
    arr[i] = function(id) {
        return function() {
            return id;
        }
    }(i);
}
for (var i in arr) {
    console.log(arr[i]());
}
```

### 참고자료(Closure)

- [생활코딩](https://www.inflearn.com/course/%EC%A7%80%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%96%B8%EC%96%B4-%EA%B8%B0%EB%B3%B8/lecture/2537)

## 01/01

- OAuth 2.0

OAuth의 전체 흐름은 아래와 같다.

일단 Client는 Resource Server에 자신의 애플리케이션(Heaven라고 해보자)을 등록하는 과정을 거친다.(그러면 Client Id, Client Secret, Redirect URL을 설정해야 한다.)

현재 상태는 아래 그림과 같다.

![OAuth2 login](/assets/img/til/oauth2-1.png)

1. 사용자(Resource Owner)는 Client(Heaven)의 Login 버튼을 누른다.
2. 그러면 Client 는 다음과 같은 페이지를 띄워준다.

![kakao login](/assets/img/til/kakao_login.png)

위의 사진 예시에서 살펴보면, `https://resource.server/?client_id=1&scope=B,C&redirect_uri=https://smjeon.dev/done`의 경로로 요청을 보낼 것이다. 그러면 Resource Server의 B, C 권한을 요청하는 인증요청을 보낸다.

그러면 Resource Server는 현재 Resource Owner가 로그인이 되어 있는지 확인 후 되어있지 않다면, 로그인을 하라는 화면을 보여준다. 로그인을 성공했다면, Resource Server는 Client ID값과 같은 Client ID가 있는 지 확인하고, redirect URI가 동일한 지 확인 한다. 동일하다면, 처음에 요청한 B, C 권한을 Client(Heaven)에 허용할 것이냐 라는 메세지를 보여준다. 그 다음 허용한다고 하면, Resource Server에 해당 정보를 기억해놓는다.

그 이후 Resource Server는 Resource Owner의 브라우저를 Redirect URI로 code를 담아서 redirect 시킨다. 그러면 이 Redirect URI로 요청을 받은 Client(Heaven)은 Authorization Code를 받는다.

Client는 이 code를 가지고 Resource Server에 직접 접근한다.(`https://resource.server/token?grant_type=authorization_code&code=3&redircet_uri=https://smjeon.dev/done&client_id=1&client_secret=2`와 같은 경로로 요청한다.) Resource Server는 Client Id, Client Secret, Code가 모두 일치하면 Client에게 해당 유저에 대한 Access Token(4)을 발급해준다.

Client(Heaven)는 발급받은 Access Token을 저장 해 둔다. 그 이후에는 이 Access Token(4)을 가지고 Resource Server에 실제 사용자(Resource Owner)의 B, C 권한에 대한 접근을 할 수 있다.

실제로 구현한 것을 기준으로 살펴보면, 1, 2번 과정을 거치면 `https://kauth.kakao.com/oauth/authorize?client_id=f2f338d4cd150b4802b3dec123673221&redirect_uri=http://localhost:8080/oauth&response_type=code` 의 경로로 요청을 보낸다.

그리고 Resource Owner는 kakao 로그인을 완료하고, 요청한 권한에 대한 승인을 한다. 그 이후 Resource Owner의 브라우저는 설정 해두었던 redirect uri인 `/oauth` 경로로 redirect 된다. redirect 할 때, code를 담아서 redirect 한다.

우리는 구현을 다음과 같이 했는데, `/oauth` 경로로 요청이 들어왔을 때, code 값을 받아오고 Resource Server인 카카오 서버에 client id와 redirect uri와 기타 정보들을 담아서 요청을 보낸다.

```java
@GetMapping("/oauth")
public ResponseEntity oauth(HttpSession httpSession, @RequestParam("code") String code) {
    LOGGER.info("code: {}", code);

    TokenInfo tokenInfo = kakaoApiService.getTokenInfo(code);
    LOGGER.info("tokenInfo: {}", tokenInfo);

    String accessToken = tokenInfo.getAccess_token();
    String refreshToken = tokenInfo.getRefresh_token();

    User user = userService.save(kakaoApiService.getUser(accessToken, refreshToken));
    LOGGER.info("user: {}", user);

    UserSession userSession = new UserSession(user.getId(), user.getName(), accessToken);
    httpSession.setAttribute(UserSession.USER_SESSION, userSession);

    HttpHeaders headers = new HttpHeaders();
    headers.add("Location", "/");
    return new ResponseEntity<String>(headers, HttpStatus.FOUND);
}

// kakaoApiService.java
public TokenInfo getTokenInfo(String code) {
    TokenInfo tokenInfo = WebClient.create(kakaoConfig.getAuth().get("host"))
            .post()
            .uri(uriBuilder -> uriBuilder
                    .path(kakaoConfig.getAuth().get("tokenPath"))
                    .queryParam("grant_type", "authorization_code")
                    .queryParam("client_id", kakaoConfig.getAuth().get("clientId"))
                    .queryParam("redirect_uri", kakaoConfig.getAuth().get("redirectUri"))
                    .queryParam("code", code).build())
            .retrieve()
            .bodyToMono(TokenInfo.class)
            .block();

    LOGGER.info("tokenInfo: {}", tokenInfo);

    return tokenInfo;
}
```

이 과정을 거친 후 Resource Server에서는 access token을 client인 나에게 발급 해준다. 응답 온 것을 살펴보면 다음과 같다. `access_token=pJqhveNPaqFToYHMT2b6JxbBgmeitxoBSYjLbAopyNkAAAFvYOJNaA, token_type=bearer, refresh_token=BlCnewxrmPdpnBEI5c_WhgtssdXAaDJzjdlqEAopyNkAAAFvYOJNZw, expires_in=21599, scope=age_range birthday account_email gender profile, refresh_token_expires_in=5183999` Access Token과 Refresh Token과 우리 어플리케이션이 요청했던 권한을 응답으로 되돌려주는 것을 알 수 있다.

이 Access Token을 가지고 Client는 Resource Server로부터 처음에 요청했던 권한에 대한 정보들을 얻을 수 있다.

카카오 로그인 API의 경우는, 설정 > 고급 > Client Secret에서 생성한 **client_secret 코드 active 상태일 경우에는 필수**로 설정해야 한다.

추가적으로 refresh_token은 설정된 유효기간 만큼 유효하고, refresh token의 만료가 1달 이내로 남은 시점에서 사용자 토근 갱신 요청을 하면 갱신된 access token과 갱신된 refresh token이 함께 반환된다. 요청은 다음과 같이 한다.

```request
curl -v -X POST https://kauth.kakao.com/oauth/token \
 -d 'grant_type=refresh_token' \
 -d 'client_id={app_key}' \
 -d 'refresh_token={refresh_token}'
```

이에 대한 응답은 다음과 같이 온다.

```response
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "access_token":"wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww",
    "token_type":"bearer",
    "refresh_token":"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",  //optional
    "expires_in":43199,
}
```

## 참고자료(OAuth 2.0)

- [생활코딩](https://opentutorials.org/course/3405)
- [Kakao API 사용자 관리 문서](https://developers.kakao.com/docs/restapi/user-management)
