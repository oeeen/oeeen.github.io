---
layout: single
title:  "TIL(1월)"
date:   2020-01-01 12:00:59 +0900
classes: wide
categories: etc
tags: web
---

**틀린 내용이나 본문의 내용과 다른 의견이 있으시면 댓글로 남겨주세요!**

## 01/01

- OAuth 2.0

OAuth의 전체 흐름은 아래와 같다.

일단 Client는 Resource Server에 자신의 애플리케이션(Heaven라고 해보자)을 등록하는 과정을 거친다.(그러면 Client Id, Client Secret, Redirect URL을 설정해야 한다.)

현재 상태는 아래 그림과 같다.

![OAuth2 login](/assets/img/til/oauth2-1.png)

1. 사용자(Resource Owner)는 Client(Heaven)의 Login 버튼을 누른다.
2. 그러면 Client 는 다음과 같은 페이지를 띄워준다.

![kakao login](/assets/img/til/kakao_login.png)

위의 사진 예시에서 살펴보면, `https://resource.server/?client_id=1&scope=B,C&redirect_uri=https://smjeon.dev/done`의 경로로 요청을 보낼 것이다. 그러면 Resource Server의 B, C 권한을 요청하는 인증요청을 보낸다.

그러면 Resource Server는 현재 Resource Owner가 로그인이 되어 있는지 확인 후 되어있지 않다면, 로그인을 하라는 화면을 보여준다. 로그인을 성공했다면, Resource Server는 Client ID값과 같은 Client ID가 있는 지 확인하고, redirect URI가 동일한 지 확인 한다. 동일하다면, 처음에 요청한 B, C 권한을 Client(Heaven)에 허용할 것이냐 라는 메세지를 보여준다. 그 다음 허용한다고 하면, Resource Server에 해당 정보를 기억해놓는다.

그 이후 Resource Server는 Resource Owner의 브라우저를 Redirect URI로 code를 담아서 redirect 시킨다. 그러면 이 Redirect URI로 요청을 받은 Client(Heaven)은 Authorization Code를 받는다.

Client는 이 code를 가지고 Resource Server에 직접 접근한다.(`https://resource.server/token?grant_type=authorization_code&code=3&redircet_uri=https://smjeon.dev/done&client_id=1&client_secret=2`와 같은 경로로 요청한다.) Resource Server는 Client Id, Client Secret, Code가 모두 일치하면 Client에게 해당 유저에 대한 Access Token(4)을 발급해준다.

Client(Heaven)는 발급받은 Access Token을 저장 해 둔다. 그 이후에는 이 Access Token(4)을 가지고 Resource Server에 실제 사용자(Resource Owner)의 B, C 권한에 대한 접근을 할 수 있다.

실제로 구현한 것을 기준으로 살펴보면, 1, 2번 과정을 거치면 `https://kauth.kakao.com/oauth/authorize?client_id=f2f338d4cd150b4802b3dec123673221&redirect_uri=http://localhost:8080/oauth&response_type=code` 의 경로로 요청을 보낸다.

그리고 Resource Owner는 kakao 로그인을 완료하고, 요청한 권한에 대한 승인을 한다. 그 이후 Resource Owner의 브라우저는 설정 해두었던 redirect uri인 `/oauth` 경로로 redirect 된다. redirect 할 때, code를 담아서 redirect 한다.

우리는 구현을 다음과 같이 했는데, `/oauth` 경로로 요청이 들어왔을 때, code 값을 받아오고 Resource Server인 카카오 서버에 client id와 redirect uri와 기타 정보들을 담아서 요청을 보낸다.

```java
@GetMapping("/oauth")
public ResponseEntity oauth(HttpSession httpSession, @RequestParam("code") String code) {
    LOGGER.info("code: {}", code);

    TokenInfo tokenInfo = kakaoApiService.getTokenInfo(code);
    LOGGER.info("tokenInfo: {}", tokenInfo);

    String accessToken = tokenInfo.getAccess_token();
    String refreshToken = tokenInfo.getRefresh_token();

    User user = userService.save(kakaoApiService.getUser(accessToken, refreshToken));
    LOGGER.info("user: {}", user);

    UserSession userSession = new UserSession(user.getId(), user.getName(), accessToken);
    httpSession.setAttribute(UserSession.USER_SESSION, userSession);

    HttpHeaders headers = new HttpHeaders();
    headers.add("Location", "/");
    return new ResponseEntity<String>(headers, HttpStatus.FOUND);
}

// kakaoApiService.java
public TokenInfo getTokenInfo(String code) {
    TokenInfo tokenInfo = WebClient.create(kakaoConfig.getAuth().get("host"))
            .post()
            .uri(uriBuilder -> uriBuilder
                    .path(kakaoConfig.getAuth().get("tokenPath"))
                    .queryParam("grant_type", "authorization_code")
                    .queryParam("client_id", kakaoConfig.getAuth().get("clientId"))
                    .queryParam("redirect_uri", kakaoConfig.getAuth().get("redirectUri"))
                    .queryParam("code", code).build())
            .retrieve()
            .bodyToMono(TokenInfo.class)
            .block();

    LOGGER.info("tokenInfo: {}", tokenInfo);

    return tokenInfo;
}
```

이 과정을 거친 후 Resource Server에서는 access token을 client인 나에게 발급 해준다. 응답 온 것을 살펴보면 다음과 같다. `access_token=pJqhveNPaqFToYHMT2b6JxbBgmeitxoBSYjLbAopyNkAAAFvYOJNaA, token_type=bearer, refresh_token=BlCnewxrmPdpnBEI5c_WhgtssdXAaDJzjdlqEAopyNkAAAFvYOJNZw, expires_in=21599, scope=age_range birthday account_email gender profile, refresh_token_expires_in=5183999` Access Token과 Refresh Token과 우리 어플리케이션이 요청했던 권한을 응답으로 되돌려주는 것을 알 수 있다.

이 Access Token을 가지고 Client는 Resource Server로부터 처음에 요청했던 권한에 대한 정보들을 얻을 수 있다.

카카오 로그인 API의 경우는, 설정 > 고급 > Client Secret에서 생성한 **client_secret 코드 active 상태일 경우에는 필수**로 설정해야 한다.

추가적으로 refresh_token은 설정된 유효기간 만큼 유효하고, refresh token의 만료가 1달 이내로 남은 시점에서 사용자 토근 갱신 요청을 하면 갱신된 access token과 갱신된 refresh token이 함께 반환된다. 요청은 다음과 같이 한다.

```request
curl -v -X POST https://kauth.kakao.com/oauth/token \
 -d 'grant_type=refresh_token' \
 -d 'client_id={app_key}' \
 -d 'refresh_token={refresh_token}'
```

이에 대한 응답은 다음과 같이 온다.

```response
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "access_token":"wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww",
    "token_type":"bearer",
    "refresh_token":"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",  //optional
    "expires_in":43199,
}
```

## 참고자료(OAuth 2.0)

- [생활코딩](https://opentutorials.org/course/3405)
- [Kakao API 사용자 관리 문서](https://developers.kakao.com/docs/restapi/user-management)
