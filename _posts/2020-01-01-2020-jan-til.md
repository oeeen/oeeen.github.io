---
layout: single
title:  "TIL(1월)"
date:   2020-01-01 12:00:59 +0900
classes: wide
categories: etc
tags: web
---

**틀린 내용이나 본문의 내용과 다른 의견이 있으시면 댓글로 남겨주세요!**

## 01/02

## Java에서 Exception에 관하여

1. Exception은 개발자가 구현한 로직에서 발생한다. 예외는 발생할 상황을 미리 예측해서 처리할 수 있다. 예외는 개발자가 처리 할 수 있기 때문에, 예외를 구분하고 그에 따른 처리 방법을 명확히 알고 적용하는 것이 중요하다.
2. Exception은 개발자가 로직을 추가하여 처리할 수 있다.
3. Exception은 많은 자식 클래스를 가지고 있다.
4. RuntimeException은 CheckedException과 UncheckedException을 구분하는 기준이다. RuntimeException을 제외한 모든 Exception의 자식 클래스는 CheckedException이고 RuntimeException과 그의 자식 클래스들은 모두 UncheckedException이다.

CheckedException => RuntimeException을 제외한 모든 Exception => 반드시 처리해 주어야 함(메서드 밖으로 throw하거나 catch 해줘야함)

### Checked Exception

- 반드시 예외를 처리해야 함
- 컴파일 단계에서 확인(CompileTime Exception)
- Roll-back 하지 않는다(Transaction 처리)
- Runtime Exception을 제외한 모든 예외

### Unchecked Exception

- 반드시 처리하지 않아도 됨.
- 실행 단계에서 확인(Runtime Exception)
- Roll-back
- ex) NullPointerException, IllegalArgumentException, IndexOutOfBoundException, SystemException 등

그러면 Checked Exception은 언제 써야할까? 내 생각으로는 컴파일 타임에 예외를 확인해야 할 때, 개발자가 **어떤 상황에서 발생하는지 예측할 수 없는** 예외 상황(SQL Exception 같이?)일 경우에는 Checked Exception이 사용 되는 것 같다. 그래서 언제 발생할지 모르지만 `이 예외가 발생할 경우엔 어떻게 처리해줘!`라고 개발자가 따로 처리 로직을 개발할 필요가 있는 것 같다.

그러면 Checked Exception vs. Unchecked Exception 은?

가장 큰 차이는 예외를 명시적으로 처리 해주어야 하냐, 아니냐의 차이이다. 그리고 잘은 모르지만 예외 발생 시 트랜잭션을 roll-back 하느냐, 안하느냐 의 차이도 있다.

내 경우엔 CustomException은 모두 RuntimeException을 상속받아서 만들었는데, 이유는 Custom으로 만든 예외들은 모두 내가 예측 가능한 상황(유저가 패스워드를 틀리거나, DB에 없는 유저로 로그인을 하려고 한다거나..)에 대한 예외이기 때문에, 이에 대한 처리를 따로 하지 않고, 어떤 요청이 들어왔는지 로그로 남겨놓을 때 명시적으로 어떤 문제 때문에 발생했는지 표현하기 위해서 만들었다.

## 01/01

- OAuth 2.0

OAuth의 전체 흐름은 아래와 같다.

일단 Client는 Resource Server에 자신의 애플리케이션(Heaven라고 해보자)을 등록하는 과정을 거친다.(그러면 Client Id, Client Secret, Redirect URL을 설정해야 한다.)

현재 상태는 아래 그림과 같다.

![OAuth2 login](/assets/img/til/oauth2-1.png)

1. 사용자(Resource Owner)는 Client(Heaven)의 Login 버튼을 누른다.
2. 그러면 Client 는 다음과 같은 페이지를 띄워준다.

![kakao login](/assets/img/til/kakao_login.png)

위의 사진 예시에서 살펴보면, `https://resource.server/?client_id=1&scope=B,C&redirect_uri=https://smjeon.dev/done`의 경로로 요청을 보낼 것이다. 그러면 Resource Server의 B, C 권한을 요청하는 인증요청을 보낸다.

그러면 Resource Server는 현재 Resource Owner가 로그인이 되어 있는지 확인 후 되어있지 않다면, 로그인을 하라는 화면을 보여준다. 로그인을 성공했다면, Resource Server는 Client ID값과 같은 Client ID가 있는 지 확인하고, redirect URI가 동일한 지 확인 한다. 동일하다면, 처음에 요청한 B, C 권한을 Client(Heaven)에 허용할 것이냐 라는 메세지를 보여준다. 그 다음 허용한다고 하면, Resource Server에 해당 정보를 기억해놓는다.

그 이후 Resource Server는 Resource Owner의 브라우저를 Redirect URI로 code를 담아서 redirect 시킨다. 그러면 이 Redirect URI로 요청을 받은 Client(Heaven)은 Authorization Code를 받는다.

Client는 이 code를 가지고 Resource Server에 직접 접근한다.(`https://resource.server/token?grant_type=authorization_code&code=3&redircet_uri=https://smjeon.dev/done&client_id=1&client_secret=2`와 같은 경로로 요청한다.) Resource Server는 Client Id, Client Secret, Code가 모두 일치하면 Client에게 해당 유저에 대한 Access Token(4)을 발급해준다.

Client(Heaven)는 발급받은 Access Token을 저장 해 둔다. 그 이후에는 이 Access Token(4)을 가지고 Resource Server에 실제 사용자(Resource Owner)의 B, C 권한에 대한 접근을 할 수 있다.

실제로 구현한 것을 기준으로 살펴보면, 1, 2번 과정을 거치면 `https://kauth.kakao.com/oauth/authorize?client_id=f2f338d4cd150b4802b3dec123673221&redirect_uri=http://localhost:8080/oauth&response_type=code` 의 경로로 요청을 보낸다.

그리고 Resource Owner는 kakao 로그인을 완료하고, 요청한 권한에 대한 승인을 한다. 그 이후 Resource Owner의 브라우저는 설정 해두었던 redirect uri인 `/oauth` 경로로 redirect 된다. redirect 할 때, code를 담아서 redirect 한다.

우리는 구현을 다음과 같이 했는데, `/oauth` 경로로 요청이 들어왔을 때, code 값을 받아오고 Resource Server인 카카오 서버에 client id와 redirect uri와 기타 정보들을 담아서 요청을 보낸다.

```java
@GetMapping("/oauth")
public ResponseEntity oauth(HttpSession httpSession, @RequestParam("code") String code) {
    LOGGER.info("code: {}", code);

    TokenInfo tokenInfo = kakaoApiService.getTokenInfo(code);
    LOGGER.info("tokenInfo: {}", tokenInfo);

    String accessToken = tokenInfo.getAccess_token();
    String refreshToken = tokenInfo.getRefresh_token();

    User user = userService.save(kakaoApiService.getUser(accessToken, refreshToken));
    LOGGER.info("user: {}", user);

    UserSession userSession = new UserSession(user.getId(), user.getName(), accessToken);
    httpSession.setAttribute(UserSession.USER_SESSION, userSession);

    HttpHeaders headers = new HttpHeaders();
    headers.add("Location", "/");
    return new ResponseEntity<String>(headers, HttpStatus.FOUND);
}

// kakaoApiService.java
public TokenInfo getTokenInfo(String code) {
    TokenInfo tokenInfo = WebClient.create(kakaoConfig.getAuth().get("host"))
            .post()
            .uri(uriBuilder -> uriBuilder
                    .path(kakaoConfig.getAuth().get("tokenPath"))
                    .queryParam("grant_type", "authorization_code")
                    .queryParam("client_id", kakaoConfig.getAuth().get("clientId"))
                    .queryParam("redirect_uri", kakaoConfig.getAuth().get("redirectUri"))
                    .queryParam("code", code).build())
            .retrieve()
            .bodyToMono(TokenInfo.class)
            .block();

    LOGGER.info("tokenInfo: {}", tokenInfo);

    return tokenInfo;
}
```

이 과정을 거친 후 Resource Server에서는 access token을 client인 나에게 발급 해준다. 응답 온 것을 살펴보면 다음과 같다. `access_token=pJqhveNPaqFToYHMT2b6JxbBgmeitxoBSYjLbAopyNkAAAFvYOJNaA, token_type=bearer, refresh_token=BlCnewxrmPdpnBEI5c_WhgtssdXAaDJzjdlqEAopyNkAAAFvYOJNZw, expires_in=21599, scope=age_range birthday account_email gender profile, refresh_token_expires_in=5183999` Access Token과 Refresh Token과 우리 어플리케이션이 요청했던 권한을 응답으로 되돌려주는 것을 알 수 있다.

이 Access Token을 가지고 Client는 Resource Server로부터 처음에 요청했던 권한에 대한 정보들을 얻을 수 있다.

카카오 로그인 API의 경우는, 설정 > 고급 > Client Secret에서 생성한 **client_secret 코드 active 상태일 경우에는 필수**로 설정해야 한다.

추가적으로 refresh_token은 설정된 유효기간 만큼 유효하고, refresh token의 만료가 1달 이내로 남은 시점에서 사용자 토근 갱신 요청을 하면 갱신된 access token과 갱신된 refresh token이 함께 반환된다. 요청은 다음과 같이 한다.

```request
curl -v -X POST https://kauth.kakao.com/oauth/token \
 -d 'grant_type=refresh_token' \
 -d 'client_id={app_key}' \
 -d 'refresh_token={refresh_token}'
```

이에 대한 응답은 다음과 같이 온다.

```response
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
{
    "access_token":"wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww",
    "token_type":"bearer",
    "refresh_token":"zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz",  //optional
    "expires_in":43199,
}
```

## 참고자료(OAuth 2.0)

- [생활코딩](https://opentutorials.org/course/3405)
- [Kakao API 사용자 관리 문서](https://developers.kakao.com/docs/restapi/user-management)
