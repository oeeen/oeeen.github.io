---
layout: single
title:  "Linux Command Line 4"
date:   2019-08-11 01:20:59 +0900
classes: wide
categories: etc
tag: linux
toc: true
toc_sticky: true
---

## 프로세스

### ps

간단하게 ps 명령어는 프로세스를 볼수 있다.

![ps](/assets/img/command/ps.png)

`ps x` command로 제어되는 터미널에 상관 없이 모든 프로세스를 볼 수 있다.

![ps_x](/assets/img/command/ps_x.png)

ps 명령어의 결과는

PID | TTY | STAT | TIME | COMMAND
--- | --- | ---- | ---- | -------
xxx | ?   | S    | 0:00 | /usr/sbin/xxx

와 같은 식으로 구성되어 있다.

* PID - Process ID
* TTY - teletype의 약자로 프로세스용 제어 터미널
* STAT - 프로세스의 현재 상태를 나타낸다.
* TIME - 프로세스의 CPU 사용 시간
* COMMAND - 커맨드

#### 프로세스 상태

상태 값 | 의미
------|----
R | 실행 상태, 실행 중이거나 실행 대기 중
S | 수면 상태, 키 입력이나 네트워크 패킷과 같은 이벤트를 기다리는 중
D | 인터럽트 불가능한 수면 상태. I/O를 기다리는 중
T | 종료 상태, 종료 되었거나 종료 요청을 받은 상태
Z | 현존하지 않거나 "좀비" 프로세스. 부모 프로세스에 의해 정리되지 않은 종료된 자식 프로세스
< | 높은 우선순위 프로세스, 특정 프로세스에 더 중요성을 부여하는 것이 가능하다.
N | 낮은 우선순위 프로세스

보통 많이 사용하는 옵션은 `ps aux`다

![ps_aux](/assets/img/command/ps_aux.png)

* USER - 사용자 ID (프로세스 소유자)
* %CPU - CPU 사용량
* %MEM - 메모리 사용량
* VSZ - 가상 메모리 크기
* RSS - 사용 메모리 크기. 프로세스가 사용중인 물리적 메모리 량을 나타냄
* START - 프로세스가 시작된 시각

## top

시스템 활동을 좀더 동적으로 보기 위해서 top 명령어를 사용한다.

![top](/assets/img/command/top.png)

맥에서의 top과 linux(ubuntu)에서의 top이 약간 달라서 사진을 추가한다.

![linux_top](/assets/img/command/linux_top.png)

결국에 나타내주는 정보는 비슷하다. 리눅스 기준으로 정리하면

top | 15:49:27 | up 14:02 | 0 users | load average
--- | ---------| ----------| --------| ---------
프로그램이름 |현재시각 | 시스템 업타임 | 유저 수 | 평균부하

### load average

평균 부하는 실행 대기중인 프로세스 수, 실행 가능한 상태이며 CPU를 공유하고 있는 프로세스 수.3가지 숫자는 각각 1: 최근 60초 동안 평균값, 2: 지난 5분, 3: 지난 15분 간 평균값

* Task: 총 프로세스 수와 각 상태별 프로세스 수를 나타냄

%Cpu(s) | 0.1 us | 0.1 sy | 0.0 ni | 99.8 id | 0.0 wa
--- | --- | --- | --- | --- | ---
- | 0.1의 사용자 프로세스 | 0.1 시스템 프로세스 | 0.0 낮은 우선순위 프로세스 | 99.8 유휴상태 | 0.0 I/O 대기

* MeM: 물리 메모리 사용현황
* Swap: 스왑영역 사용현황

## 프로세스 제어

### 프로세스를 백그라운드로 전환

만약 자바 어플리케이션을 백그라운드로 실행 시키고 싶다면?
`java -jar myblog.jar &` 과 같이 뒤에 &을 붙여주면 된다.

백그라운드로 실행되고 있는 프로세스를 포그라운드 실행으로 바꾸고 싶다면
`fg %1` 과 같이 작업 번호를 입력해서 포그라운드로 전환한다.

프로세스를 일시정지 하고싶다면 CTRL + Z로 일시정지 한다.
그 이후 `bg %1` 과 같이 작업 번호를 입력해서 백그라운드로 전환한다.

### kill

내 소유의 프로세스들에 시그널을 보낸다. (내 소유가 아닌 프로세스에 보내려면 슈퍼유저 권한이 있어야 한다.)

주요 시그널은 아래와 같다.

번호 | 이름 |의미
:----:|:----:|:----
1 | HUP | Hang  up, 이 시그널은 터미널 세션 종료에 의해 나타난다.
2 | INT | Interrupt, 터미널에서 CTRL + C와 동일
6 | ABRT | Abort
9 | KILL | kill, kill 시그널은 프로세스에게 보내지 않고 커널에게 보낸다. 커널이 프로세스를 즉시 종료시킨다. 프로세스는 스스로 정리하거나 진행 중인 작업을 저장 할 수 없다.
14 | ALRM | Alarm clock
15 | TERM | Terminate, kill 명령어가 보내는 기본 신호다. 프로세스가 시그널을 받을 수 있는 상태라면 종료될 것이다.
18 | CONT | Continue, STOP 시그널로 정지된 프로세스를 복원한다.
19 | STOP | Stop, 프로세스를 종료하지 않고 정지 시킨다. kill 처럼 해당 프로세스에 직접 보내지 않는다. 따라서 이 시그널을 무시할 수 없다.

다른 시그널들은 아래 그림에서 볼 수 있다.

![kill -l](/assets/img/command/kill_l.png)

다른 시그널들에 대한 설명은 `man kill`을 참고하자.

### **killall**

`killall [-u user] [-signal] name ...`
명령으로 명시된 프로세스나 사용자 이름이 일치하는 다수의 프로세스에 시그널을 보낼 수 있다.

## 기타 프로세스 관련 명령어

명령어 | 설명
---- | ----
pstree | 프로세스 간의 부모/자식 관계를 보여주는 트리형태로 정렬해서 프로세스 목록을 출력
vmstat | 메모리, 스왑, 디스크 I/O를 포함한 시스템 자원 사용 현황을 출력한다.
xload | 시간에 따라 시스템 부하를 그래프로 보여주는 그래픽 프로그램이다.
tload | xload와 비슷하지만 터미널에서 그래프를 보여준다.
