---
layout: single
title:  "TIL(2월) - 1"
date:   2020-02-01 12:00:59 +0900
classes: wide
categories: etc
tags: web
description: >
  매일 공부한 내용을 정리합니다. 간단하게 링크로 보았던 내용들은 링크로 남깁니다.
---

**틀린 내용이나 본문의 내용과 다른 의견이 있으시면 댓글로 남겨주세요!**

## 02/03

### Merge Sort

하나의 리스트를 같은 크기의 부분 리스트로 나누고, 나누어진 부분 리스트를 각각 정렬하고 정렬된 부분 리스트를 합쳐서 전체 리스트를 만든다.

다음과 같은 단계로 이루어진다.

1. 분할 - 하나의 리스트를 같은 크기의 2개의 부분 배열로 분할
2. 정복 - 부분 배열을 정렬한다. 여기서 재귀적으로 1. 분할, 2. 정복의 방법을 적용한다.
3. 결합 - 최종적으로 정렬된 부분 배열을 하나의 배열로 합친다.

전체 N개의 원소를 정렬한다고 했을 때, 한번 나눌 때 N/2가 되어 최종적으로 1개의 원소로 쪼개졌을 때, 맨 마지막 부분 배열의 개수는 N개가 되고 이 N개의 부분 배열을 N/2개의 부분배열로 합치려면, N/2 쌍을 2번씩의 비교가 필요하다. 그 다음은 N/2개의 부분 배열을 합치려면 N/4쌍 리스트를 4번씩 비교를 해야한다. 그래서 한 라인 별로 총 N번의 연산이 필요하고, N~1 까지 2로 나눈 리스트를 만드는 경우에 전체 이진 트리의 높이는 logN이기 때문에, 결국 최종적으로 시간 복잡도는 O(nlogn)이다.

![Divide](/assets/img/til/divide.png)

위와 같은 방식으로 간단하게 부분 배열로 나눈다. 최종적으로 크기가 1인 배열이 되면 그만 나눈다.

![Conquer](/assets/img/til/conquer.png)

나누어진 상태에서 각 배열을 합치면서, 배열의 값들을 비교하며 크기별로 정렬한다. 위 그림에서 두번째 줄을 보면, 8개의 부분 배열을 합치며 총 4쌍의 부분 배열이 만들어지고, 2번씩의 비교가 필요해 총 8번의 연산이 필요한 것을 볼 수 있다. 세번째 줄을 보면, 4개의 부분 배열을 합치면서 총 2쌍의 부분 배열(1,2,5,7 / 3,4,6,10)이 만들어지고, 만들기 위해 총 4번 씩의 비교가 필요해서 결과적으로 총 8번의 연산이 필요한 것을 알 수 있다. 그리고 이 구조를 이진 트리라고 생각할 수 있으므로, 이 트리의 높이는 logN으로 최종적으로 머지소트의 시간복잡도는 O(NlogN)이다.(worst, best, average case 모두)

아래는 머지소트를 간단하게 구현해 본 내용이다.

```c
void mergeSort(int a[], int n){
    if(n == 1){
        return;
    }

    int i,j,k;
    int tArr[n];
    int m = n / 2;

    mergeSort(a, m);
    mergeSort(a + m, n - m);

    i = 0;
    j = m;
    k = 0;

    while (i < m && j < n) {
        tArr[k++] = a[i] < a[j] ? a[i++] : a[j++];
    }
    while (i < m) {
        tArr[k++] = a[i++];
    }
    while (j < n) {
        tArr[k++] = a[j++];
    }
    for(i = 0; i < n ; i++){
        a[i] = tArr[i];
    }
}
```

## 02/02

### PCB (Process Control Block)

말 그대로, 프로세스를 관리하기 위한 OS의 자료구조이다. 그렇기 때문에, 프로세스를 관리하는데 있어 필요한 정보들이 담겨져 있다.

여기서 프로세스의 위키 내용을 보면 아래와 같다.

> 프로세스(process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다. 종종 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰인다. 여러 개의 프로세서를 사용하는 것을 멀티프로세싱이라고 하며 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹이라고 한다. 프로세스 관리는 운영 체제의 중요한 부분이 되었다.

정리 해보면

1. 실행중인 프로그램
2. 커널에 의해 관리되고 등록된 엔티티
3. 시스템 자원을 사용하고, 요청할 수 있게 허가된 엔티티
4. PCB에 할당된 엔티티

PCB는 프로세스를 관리하기 위한 자료구조고, 프로세스는 PCB에 할당된 엔티티라고 하니까 좀 순환참조 느낌이다.

PCB는 일단 아래와 같은 구조로 되어있다.

![PCB](/assets/img/til/pcb.jpg)

OS 마다 PCB는 다른 구조를 가질 것이다. PCB는 Process ID라는 고유한 값으로 구분되고, 프로세스의 라이프 타임 동안 유지되며, 프로세스가 종료되면 사라진다.

### 참고자료(PCB)

- [TutorialsPoint](https://www.tutorialspoint.com/operating_system/os_processes.htm)
- [andole98: OS-Concept](https://github.com/andole98/OS-Concept#%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4)

### Context Switching

말 그대로 현재 실행중인 프로세스를 멈추고, Context를 Switching 한다. 현재 실행중인 프로세스를 멈추려면 실행중인 프로세스의 정보를 저장해두어야 한다. 프로세스에 대한 정보는 PCB에 있다. Ready 상태인 프로세스와 Running 상태인 프로세스가 인터럽트에 의해 서로 상태가 transition된다.

컨텍스트 스위칭은 CPU에 많은 부하를 가져다 준다. 컨텍스트 스위칭이 일어나는 동안 CPU는 아무런 일도 하지 못한다. 커널은 Ready 상태로 돌아가는 프로세스의 정보를 PCB에 저장하고 Running 상태로 들어갈 프로세스의 Context를 CPU에 적재한다.

Context Switching 비용은 Process가 Thread보다 많이 든다. 그 이유는 Thread는 Stack을 제외한 Code, Data 영역은 다른 쓰레드에서도 공유하기 때문에 이 부분은 컨텍스트 스위칭에 들어가지 않는다.
