---
layout: single
title:  "TIL(2월) - 1"
date:   2020-02-01 12:00:59 +0900
classes: wide
categories: etc
tags: web
toc: true
toc_sticky: true
---

**틀린 내용이나 본문의 내용과 다른 의견이 있으시면 댓글로 남겨주세요!**

## 02/11

### Spring Interceptor와 Filter

Filter와 Interceptor는 Controller에 요청이 들어오기전에 어떤 처리를 한다는 점에서 비슷하게 생각할 수 있다. 하지만 Filter는 DispatcherServlet 이전에 로직을 수행하고, Interceptor는 Controller 이전에 로직을 수행한다.

Filter가 어느 위치에서 어떤 일을 하는 지는 알겠는데, 좀 더 알아보기 위해서 주석을 읽어보았다. Filter interface의 주석을 보면 아래와 같다.

```java
/**
 * <p>A filter is an object that performs
 * filtering tasks on either the request to a resource (a servlet or static content), or on the response
 * from a resource, or both.</p>
 *
 * <p>Filters perform filtering in the <code>doFilter</code> method.
 * Every Filter has access to a FilterConfig object from which it can obtain
 * its initialization parameters, and a reference to the ServletContext which
 * it can use, for example, to load resources needed for filtering tasks.
 *
 * <p>Filters are configured in the deployment descriptor of a web
 * application.
 *
 * <p>Examples that have been identified for this design are:
 * <ol>
 * <li>Authentication Filters
 * <li>Logging and Auditing Filters
 * <li>Image conversion Filters
 * <li>Data compression Filters
 * <li>Encryption Filters
 * <li>Tokenizing Filters
 * <li>Filters that trigger resource access events
 * <li>XSL/T filters
 * <li>Mime-type chain Filter
 * </ol>
 *
 * @since Servlet 2.3
 */

public interface Filter {
/**
* <p>Called by the web container
* to indicate to a filter that it is being placed into service.</p>
*
* <p>The servlet container calls the init
* method exactly once after instantiating the filter. The init
* method must complete successfully before the filter is asked to do any
* filtering work.</p>
*
* <p>The web container cannot place the filter into service if the init
* method either</p>
* <ol>
* <li>Throws a ServletException
* <li>Does not return within a time period defined by the web container
* </ol>
*
* @implSpec
* The default implementation takes no action.
*
* @param filterConfig a <code>FilterConfig</code> object containing the
*                     filter's configuration and initialization parameters
* @throws ServletException if an exception has occurred that interferes with
*                          the filter's normal operation
*/
default public void init(FilterConfig filterConfig) throws ServletException {}

/**
* The <code>doFilter</code> method of the Filter is called by the
* container each time a request/response pair is passed through the
* chain due to a client request for a resource at the end of the chain.
* The FilterChain passed in to this method allows the Filter to pass
* on the request and response to the next entity in the chain.
*
* <p>A typical implementation of this method would follow the following
* pattern:
* <ol>
* <li>Examine the request
* <li>Optionally wrap the request object with a custom implementation to
* filter content or headers for input filtering
* <li>Optionally wrap the response object with a custom implementation to
* filter content or headers for output filtering
* <li>
* <ul>
* <li><strong>Either</strong> invoke the next entity in the chain
* using the FilterChain object
* (<code>chain.doFilter()</code>),
* <li><strong>or</strong> not pass on the request/response pair to
* the next entity in the filter chain to
* block the request processing
* </ul>
* <li>Directly set headers on the response after invocation of the
* next entity in the filter chain.
* </ol>
*
* @param request the <code>ServletRequest</code> object contains the client's request
* @param response the <code>ServletResponse</code> object contains the filter's response
* @param chain the <code>FilterChain</code> for invoking the next filter or the resource
* @throws IOException if an I/O related error has occurred during the processing
* @throws ServletException if an exception occurs that interferes with the
*                          filter's normal operation
*
* @see UnavailableException
*/
public void doFilter(ServletRequest request, ServletResponse response,
                        FilterChain chain)
        throws IOException, ServletException;
```

필터는 리소스에 대한 요청이나 응답에 대한 필터링을 수행하는 객체이다. 필터는 doFilter() 메서드로 필터링을 수행한다.
모든 필터는 초기화 파라미터를 얻을 수 있는 필터 설정 객체에 대한 접근 권한과 필터링 작업에 필요한 리소스를 로드하는 데 사용할 수 있는 서블릿 컨텍스트에 대한 참조가 있다.

웹 컨테이너에 의해 호출되고 필터로 쓰이고 있음을 표시한다. 서블릿 컨테이너는 필터를 인스턴스화한 후 딱 한 번 init method를 호출한다. Init method는 필터가 필터링 작업을 수행하기 전에 성공적으로 완료 되어야 한다.

doFilter method는 체인의 끝에 있는 자원에 대한 클라이언트의 요청으로 인해 Request/Response pair가 체인을 통과할 때마다 컨테이너에 의해 호출된다. 이 메서드에 도착한 필터 체인은 체인의 다음 엔티티에 요청과 응답을 전달 할 수 있도록 한다. 이 메서드의 일반적인 구현은 아래와 같다.

1. Request 검토?
2. 입력 필터링을 위한 컨텐츠 또는 헤더를 필터링 하기 위한 커스텀 구현으로 Request 객체 포장
3. 출력 필터링을 위한 컨텐츠, 헤더를 필터릴 하기 위한 커스텀 구현으로 Response 객체 포장

FilterChain을 타고 가면서 Request, Response 객체를 커스텀하게 구현하며 변경, 또는 어떤 필터링 기준으로 설정할 수 있는 것으로 보인다.

Filter는 J2EE 표준 스펙의 Servlet 기술 중 하나 이고 Interceptor는 스프링에 있는 영역이다.

## 02/03

### Merge Sort

하나의 리스트를 같은 크기의 부분 리스트로 나누고, 나누어진 부분 리스트를 각각 정렬하고 정렬된 부분 리스트를 합쳐서 전체 리스트를 만든다.

다음과 같은 단계로 이루어진다.

1. 분할 - 하나의 리스트를 같은 크기의 2개의 부분 배열로 분할
2. 정복 - 부분 배열을 정렬한다. 여기서 재귀적으로 1. 분할, 2. 정복의 방법을 적용한다.
3. 결합 - 최종적으로 정렬된 부분 배열을 하나의 배열로 합친다.

전체 N개의 원소를 정렬한다고 했을 때, 한번 나눌 때 N/2가 되어 최종적으로 1개의 원소로 쪼개졌을 때, 맨 마지막 부분 배열의 개수는 N개가 되고 이 N개의 부분 배열을 N/2개의 부분배열로 합치려면, N/2 쌍을 2번씩의 비교가 필요하다. 그 다음은 N/2개의 부분 배열을 합치려면 N/4쌍 리스트를 4번씩 비교를 해야한다. 그래서 한 라인 별로 총 N번의 연산이 필요하고, N~1 까지 2로 나눈 리스트를 만드는 경우에 전체 이진 트리의 높이는 logN이기 때문에, 결국 최종적으로 시간 복잡도는 O(nlogn)이다.

![Divide](/assets/img/til/divide.png)

위와 같은 방식으로 간단하게 부분 배열로 나눈다. 최종적으로 크기가 1인 배열이 되면 그만 나눈다.

![Conquer](/assets/img/til/conquer.png)

나누어진 상태에서 각 배열을 합치면서, 배열의 값들을 비교하며 크기별로 정렬한다. 위 그림에서 두번째 줄을 보면, 8개의 부분 배열을 합치며 총 4쌍의 부분 배열이 만들어지고, 2번씩의 비교가 필요해 총 8번의 연산이 필요한 것을 볼 수 있다. 세번째 줄을 보면, 4개의 부분 배열을 합치면서 총 2쌍의 부분 배열(1,2,5,7 / 3,4,6,10)이 만들어지고, 만들기 위해 총 4번 씩의 비교가 필요해서 결과적으로 총 8번의 연산이 필요한 것을 알 수 있다. 그리고 이 구조를 이진 트리라고 생각할 수 있으므로, 이 트리의 높이는 logN으로 최종적으로 머지소트의 시간복잡도는 O(NlogN)이다.(worst, best, average case 모두)

아래는 머지소트를 간단하게 구현해 본 내용이다.

```c
void mergeSort(int a[], int n){
    if(n == 1){
        return;
    }

    int i,j,k;
    int tArr[n];
    int m = n / 2;

    mergeSort(a, m);
    mergeSort(a + m, n - m);

    i = 0;
    j = m;
    k = 0;

    while (i < m && j < n) {
        tArr[k++] = a[i] < a[j] ? a[i++] : a[j++];
    }
    while (i < m) {
        tArr[k++] = a[i++];
    }
    while (j < n) {
        tArr[k++] = a[j++];
    }
    for(i = 0; i < n ; i++){
        a[i] = tArr[i];
    }
}
```

## 02/02

### PCB (Process Control Block)

말 그대로, 프로세스를 관리하기 위한 OS의 자료구조이다. 그렇기 때문에, 프로세스를 관리하는데 있어 필요한 정보들이 담겨져 있다.

여기서 프로세스의 위키 내용을 보면 아래와 같다.

> 프로세스(process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다. 종종 스케줄링의 대상이 되는 작업(task)이라는 용어와 거의 같은 의미로 쓰인다. 여러 개의 프로세서를 사용하는 것을 멀티프로세싱이라고 하며 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹이라고 한다. 프로세스 관리는 운영 체제의 중요한 부분이 되었다.

정리 해보면

1. 실행중인 프로그램
2. 커널에 의해 관리되고 등록된 엔티티
3. 시스템 자원을 사용하고, 요청할 수 있게 허가된 엔티티
4. PCB에 할당된 엔티티

PCB는 프로세스를 관리하기 위한 자료구조고, 프로세스는 PCB에 할당된 엔티티라고 하니까 좀 순환참조 느낌이다.

PCB는 일단 아래와 같은 구조로 되어있다.

![PCB](/assets/img/til/pcb.jpg)

OS 마다 PCB는 다른 구조를 가질 것이다. PCB는 Process ID라는 고유한 값으로 구분되고, 프로세스의 라이프 타임 동안 유지되며, 프로세스가 종료되면 사라진다.

### 참고자료(PCB)

- [TutorialsPoint](https://www.tutorialspoint.com/operating_system/os_processes.htm)
- [andole98: OS-Concept](https://github.com/andole98/OS-Concept#%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4)

### Context Switching

말 그대로 현재 실행중인 프로세스를 멈추고, Context를 Switching 한다. 현재 실행중인 프로세스를 멈추려면 실행중인 프로세스의 정보를 저장해두어야 한다. 프로세스에 대한 정보는 PCB에 있다. Ready 상태인 프로세스와 Running 상태인 프로세스가 인터럽트에 의해 서로 상태가 transition된다.

컨텍스트 스위칭은 CPU에 많은 부하를 가져다 준다. 컨텍스트 스위칭이 일어나는 동안 CPU는 아무런 일도 하지 못한다. 커널은 Ready 상태로 돌아가는 프로세스의 정보를 PCB에 저장하고 Running 상태로 들어갈 프로세스의 Context를 CPU에 적재한다.

Context Switching 비용은 Process가 Thread보다 많이 든다. 그 이유는 Thread는 Stack을 제외한 Code, Data 영역은 다른 쓰레드에서도 공유하기 때문에 이 부분은 컨텍스트 스위칭에 들어가지 않는다.
