---
layout: single
title:  "TIL(1월) - 2"
date:   2020-01-11 12:00:59 +0900
classes: wide
categories: etc
tags: web
toc: true
toc_sticky: true
---

**틀린 내용이나 본문의 내용과 다른 의견이 있으시면 댓글로 남겨주세요!**

TIL의 포스팅 길이가 과도하게 길어져 나누어서 포스팅 합니다.

## 01/14

### Javascript 기본

#### const

const는 재할당이 안된다.

기본 원칙을 다음과 같이 가져가자.

1. const를 기본으로 쓴다.
2. 그런데 변화가 생길 변수는 let을 쓴다.
3. var는 쓰지 않는다.

그러나 const여도 배열과 오브젝트의 값을 변경하는 것은 가능하다.

```javascript
const list = ["apple", "orange"];
list.push("banana");
console.log(list);
// 그러면 immutable array를 어떻게 만들까?

const list = ["apple", "orange"];
list2 = [].concat(list, "banana");
console.log(list === list2); //false;
```

ES2015 String에 추가된 메서드 - `str.startsWith(other)`, `str.endsWith(other)`, `str.includes(other)` 추가됨

for of - 순회하기

```javascript
var data = [1, 2, undefined, NaN, null, ""];

for (let value of data) {
    console.log(value);
}
```

Spread operator

```javascript
let pre = ["apple", "orange", 100];
let newData = [...pre];

console.log(pre); // ["apㅇple", "orange", 100]
console.log(newData); // ["apple", "orange", 100]
console.log(pre === newData); // false, pre와 newData는 다른 참조

function sum(a, b, c) {
    return a + b + c;
}

pre = [100, 200, 300];

console.log(sum.apply(null, pre)); // 600, 컨텍스트를 바꿔가면서 넣어준다.(?)
console.log(sum(...pre)); // 펼쳐져서 a, b, c로 들어간다.
```

from method

```javascript
function addMark() {
    let newData = [];
    for (let i = 0; i < arguments.length; i++) {
        newData.push(arguments[i] + "!");
    }

    console.log(newData);
}

addMark(1,2,3,4,5);
```

인자를 주지 않아도 arguments를 이용해서 접근할 수 있다. 여기서 arguments는 배열 처럼 생겼지만 실제 배열이 아니다. 그래서 map하는게 안된다.

```javascript
function addMark() {
    let newData = arguments.map(function(value) {
        return value + "!";
    });

    console.log(newData);
}
// 위 메서드는 안된다.

function addMark2() {
    let newArray = Array.from(arguments);
    let newData = newArray.map(function(value) {
        return value + "!";
    });

    console.log(newData);
}
// 위 방식은 가능

addMark2(1,2,3,4,5);
```

Object 생성 방식 - ES6

```javascript
function getObj() {
    const name = "crong";

    const getName = function() {
        return name;
    }

    const setName = function(newName) {
        name = newName;
    }

    const printName = function() {
        console.log(name);
    }

    return {getName, setName, name}
}

let obj = getObj();
console.log(obj.getName());
```

### 참고자료(Javascript)

- [인프런 강좌 - 모던 자바스크립트개발을 위한 ES6 강좌](https://www.inflearn.com/course/es6-%EA%B0%95%EC%A2%8C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/dashboard)

### JWT (JSON Web Token)

JSON Web Token은 다음과 같이 AAAAAAAA.BBBBBBBBB.CCCCCCC 와 같이 세 부분으로 나누어진다.

여기서 AAAAAAAA부분은 JOSE(JSON Object Signing and Encryption) 헤더, JWT Claim set, Signature 이다.

이 토큰을 어떻게 만드는지를 알아본다. RFC7519 - 7.1 Createing a JWT 부분을 보면 다음과 같다.

7.1.  Creating a JWT

JWT를 만들기 위해서는 다음과 같은 단계가 수행되어야 한다. 각 스텝의 input, output사이에는 아무련 의존성이 없다.(순서가 중요하지 않다.)

1. 원하는 Claim을 포함하는 JWT Claim을 만든다. 공백이 허용되고, 인코딩 전에 명시적으로 정규화 할 필요 없다.
2. JWT Claims Set의 UTF-8 형식으로 바꿔라
3. 원하는 헤더를 포함하는 JOSE Header를 만든다. JWT는 JWS 나 JWE 스펙을 따라야 한다. 공백이 허용되고, 인코딩 전에 명시적으로 정규화 할 필요 없다.
4. JWT가 JWS 냐, JWE에 기반하냐에 따라서 두가지 경우가 있다.
   - JWS 기반이면, JWS Payload로 JWS를 만든다. JWS 스펙에 맞게 생성해야한다.
   - JWE 기반이라면, JWE를 위해 plaintext로 메세지를 만들어서 JWE로 사용한다. JWE 스펙에 맞게 생성한다.
5. 서명 또는 암호화 작업이 수행되면, 메시지를 JWS 또는 JWE로 하고, 해당 단계에서 작성된 새로운 JOSE 헤더에서 "cty"(콘텐츠 유형) 값을 사용하여 3단계로 돌아간다.
6. 그렇지 않으면 결과 JWT를 JWS 나 JWE로 리턴한다.

JWS 스펙에 나와있는 토큰의 예시를 살짝 바꿔본 결과는 다음과 같다.

Header

```json
{
    "typ":"JWT",
    "alg":"HS256"
}
```

이를 Base64로 인코딩 하면 `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9` 이 나온다.

Payload

```json
{
  "iss":"martin",
  "exp":1300819380,
  "http://example.com/is_root":true
}
```

이를 Base64로 인코딩 하면 `eyJpc3MiOiJtYXJ0aW4iLCJleHAiOjEzMDA4MTkzODAsImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ` 이 나온다.

그리고 마지막 signature에는 위의 `Header.Payload`를 우리가 지정한 Secret과 SHA-256으로 암호화 해서 base64로 인코딩 한다.

나는 martin이라는 secret을 사용해서 암호화 하니 `mSETIt5sw3WXtHnJoczWfZJ0O6hrF6F7jT7QKW0yRXQ`와 같은 결과가 나왔다. ([jwt.io](https://jwt.io/)사이트를 이용했다.)

그러면 최종적으로 위에서 말한 AAAAAAAA.BBBBBBBBB.CCCCCCC 형식의 JWT Token이 만들어진다.(아래와 같음)

```plain
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJtYXJ0aW4iLCJleHAiOjEzMDA4MTkzODAsImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
mSETIt5sw3WXtHnJoczWfZJ0O6hrF6F7jT7QKW0yRXQ
```

jjwt 라이브러리를 활용한 Java코드는 아래와 같다. 상세한 내부 구현은 살펴보지 않아서 정확하게 알지 못하지만, 위 스펙을 따라 구현했을 것으로 예상한다.

```java
public String generateToken(String userId) {
    try {
        return Jwts.builder()
                .setHeaderParam("typ", "JWT")
                .setExpiration(new Date(System.currentTimeMillis() + (6 * 60 * 60 * 1000))) // 6 hours
                .claim("name", userId)
                .claim("scope", "normal")
                .signWith(
                        SignatureAlgorithm.HS256,
                        genKey())
                .compact();
    } catch (UnsupportedEncodingException e) {
        logger.error("Jwt Exception", e);
        throw new JwtGenerateException();
    }
}

private byte[] genKey() throws UnsupportedEncodingException {
    return SECRET.getBytes(CHARSET);
}
```

### 참고자료(JWT)

- [rfc7519 - JWT](https://tools.ietf.org/html/rfc7519)
- [rfc7515 - JWS](https://tools.ietf.org/html/rfc7515)
- [rfc7516 - JWE](https://tools.ietf.org/html/rfc7516)
- [Outsider님 블로그](https://blog.outsider.ne.kr/1160)

## 01/13

### NGINX의 HTTP Health Check

#### Passive Health Checks

NGINX는 실패한 연결을 다시 시도한다. 만약 실패한 연결이 다시 붙지 않으면, NGINX는 해당 서버를 unavailable로 표시하고 해당 서버로 요청을 보내는 것을 일시적으로 멈춘다(다시 active 표시가 될 때까지).

upstream server 아래에 있는 서버들의 설정은 그 옆에 쓰면 된다.(아래 나와있는 것처럼)

fail_timeout – max_fails 를 넘어서 connection에 실패할 때, 서버를 unavailable로 표시해놓는 시간이다. (default는 10초)
max_fails – 연결 실패의 최대 숫자이다. 이 카운트를 넘어서면 해당 서버는 unavailable 표시가 된다. (default는 1회)

```conf
upstream backend {
    server backend1.example.com;
    server backend2.example.com max_fails=3 fail_timeout=30s;
}
```

#### Active Health Check

NGINX Plus는 주기적으로 upstream server의 헬스 체크를 할 수 있다.(각 서버로 헬스체크 요청을 보내고 맞는 응답이 오는지 검증하는 방식) 아래와 같은 방식으로 사용하면 된다.

```conf
server {
    location / {
        proxy_pass http://backend;
        health_check;
    }
}
```

위 예시는 모든 요청을 upstream group인 backend로 보낸다.(health check on) default 설정으로 매 5초마다 NGINX Plus는 "/" 경로로 요청을 보낸다.(backend group안에 있는 서버들) 만약 통신 에러나, 타임아웃이 발생하면(200~399 외의 응답이 오면) health check fail이다. 그러면 server는 unhealthy 표시가 되고, 해당 서버로 요청을 더이상 보내지 않는다.(다음 health check를 통과할 때까지)

아래 설정 처럼 특정 포트로 들어오는 요청만 health check를 할 수도 있다.

```conf
server {
    location / {
        proxy_pass   http://backend;
        health_check port=8080;
    }
}
```

또 `health_check uri=/some/path`와 같은 방식으로 특정 경로로 들어오는 요청만 헬스 체크를 할 수도 있다.

그 외에 Custom Condition을 추가할 수도 있다. health_check block 에서 다음과 같이 사용할 수 있다.

```conf
http {
    #...
    match server_ok {
        status 200-399;
        body !~ "maintenance mode";
    }
    server {
        #...
        location / {
            proxy_pass http://backend;
            health_check match=server_ok;
        }
    }
}
```

위에서는 status code가 200-399 사이인지, 그리고 body에 `maintenace mode`라는게 포함 되어 있지 않다면 server_ok가 통과한다.(health check 성공)

match에서는 status code, 헤더필드, 응답의 body를 체크할 수 있다.

### 참고자료(NGINX Health Check)

- [NGINX - Http Health Check](https://docs.nginx.com/nginx/admin-guide/load-balancer/http-health-check/)

## 01/11

### Red-Black Tree

Java의 HashMap 공부를 하다가, 하나의 해시 버킷에 8개 이상의 Key-Value pair가 들어간다면 트리 구조로 바뀌는 데 이 내부 구현이 Red-Black Tree로 구현 되어 있다고 해서, Red-Black Tree에 대해 알아보았습니다.

Red-Black Tree는 Self-Balanced Binary Search Tree이다. 각 노드는 레드, 블랙 이라는 색깔을 가지고 있다. 그리고 이진 탐색 트리가 가지고 있는 기본적인 특성에 다음과 같은 특성을 가진 트리 구조를 레드 블랙 트리라고 한다.

1. 노드는 레드 혹은 블랙 중의 하나이다.
2. 루트 노드는 블랙이다.
3. 레드 노드의 자식노드 양쪽은 언제나 모두 블랙이다. (즉, 레드 노드는 연달아 나타날 수 없으며, 블랙 노드만이 레드 노드의 부모 노드가 될 수 있다)
4. 어떤 노드로부터 시작되어 리프 노드에 도달하는 모든 경로에는 리프 노드를 제외하면 모두 같은 개수의 블랙 노드가 있다.

레드-블랙 트리가 BST 중 하나이기 때문에 단순 Read에서는 BST의 구현을 그대로 사용해도 된다. 하지만 Insert/Delete의 경우에는 단순 BST의 동작을 그대로 구현하면 레드-블랙 트리의 조건을 만족하지 못한다. 그래서 레드-블랙 트리의 특수한 작업들을 해줘야한다.

다음에서 Insert/Delete 과정을 예시를 통해서 설명해본다.

단순히 다음과 같은 Tree가 있다고 생각해보자.

![Binary Search Tree](/assets/img/til/bst.png)

위와 같은 트리를 레드-블랙 트리에 맞게 색을 넣어보면 다음과 같다.

![Red-black tree](/assets/img/til/red-black-insert-1.png)

#### Insert

이 상태에서 4라는 값을 이 트리에 넣어보자. 새로운 값(4)은 일단 파란색으로 표시했다.

![Red-black tree insert](/assets/img/til/red-black-insert-2.png)

이러면 4는 레드 노드로 일단 들어가게된다.

![Red-black tree insert](/assets/img/til/red-black-insert-3.png)

그러면 초록색 박스 부분이 2개의 연속적인 레드가 나타나게 된다. 이 문제를 해결하기 위해서 Uncle Node(부모 노드의 형제)를 살펴봐야 한다.

Uncle Node가 Red면 관련된 노드들의 색을 바꾸는 작업이 필요하다. Uncle Node가 Black이면 노드들의 회전이 필요하다.

**Uncle Node - Red**인 경우 다음과 같다.

1. 삽입 한 노드의 부모, 부모의 형제 노드를 Black으로 바꾼다.
2. 삽입 한 노드의 부모의 부모 노드를 Red로 바꾼다.

현재 4를 삽입하는 과정이 위와 같은 경우다. 이를 반영하면 아래 그림처럼 된다.

![Red-black tree insert](/assets/img/til/red-black-insert-4.png)

이 경우에 다른 조건들을 만족하는지 확인 하기 위해, 애초에 레드-블랙 트리였으므로 추가된 노드들에 대해 검사해보면 된다. 그러면 A, B 노드가 Black으로 바뀌고 C노드가 Red로 바뀌면서 전체 Black의 개수는 변화가 없는 것을 확인할 수 있다. 여기서 C노드가 Root 노드 였다면 Root는 항상 Black 이어야 하므로 다시 Black으로 바뀐다. 그러므로 Root로부터 나가는 전체 Black 노드의 개수가 1개 늘어났을 뿐 동일하게 늘어났기 때문에, 4번 조건이 항상 만족된다.

이 상황에서 uncle node가 black인 경우를 확인하기 위해 위 트리에 13이라는 값을 추가해보자.

**Uncle Node - Black**인 경우 다음과 같다.

1. 삽입 한 노드와 그 부모, 부모의 부모까지를 오름차순으로 정렬한다.
2. 가운데 값을 부모로 하는 트리 형태로 만든다.
3. 부모는 Black, 자식들은 Red로 설정한다.

![Red-black tree insert](/assets/img/til/red-black-insert-5.png)

이 상태에서 순서대로 진행 해보면 다음과 같이 변한다.

![Red-black tree insert](/assets/img/til/red-black-insert-6.png)

이 노드를 그대로 붙여보면 다음과 같이 변한다.

![Red-black tree insert](/assets/img/til/red-black-insert-7.png)

이 경우에도 Black 노드의 개수가 차이가 없기 때문에, 4번 조건이 항상 만족된다.

#### Delete

삭제를 할 때 모든 경우의 수를 따져보면 다음과 같다.

1. 삭제할 노드가 Red
   - 자식 노드가 Black
2. 삭제할 노드가 Black
   - 자식 노드가 Black
   - 자식 노드가 Red

먼저 **삭제할 노드가 Red, 자식 노드가 Black** 인 경우에는

![Red-black tree delete](/assets/img/til/red-black-delete-1.png)

위와 같은 상황에서 3을 제거한다고 생각해보자.

1. 3을 지우기 위해 3의 왼쪽 자식 노드 중 가장 큰 값을 찾는다. (2)
2. 2 노드를 복사한다.(3 자리로)
3. 기존 2 노드를 제거한다.
4. 트리의 균형을 맞춘다.

![Red-black tree delete](/assets/img/til/red-black-delete.gif)

**삭제할 노드가 Black, 자식 노드가 Red**는 더 어렵지 않다.

![Red-black tree delete](/assets/img/til/red-black-delete-1.png)

위와 같은 상황에서 12를 제거한다고 해보자.

1. 일단 12를 찾는다.
2. 12의 왼쪽 자식 노드 중 최대값(9)을 찾는다.
3. 9 노드를 12의 자리로 복사한다.
4. 기존 9노드를 제거한다.

문제가 되는 경우는 **삭제할 노드가 Black, 자식 노드도 Black** 인 경우이다.

1. 삭제할 노드의 형제 노드가 Red
   - 형제 노드를 Black으로 바꿈
2. 형제 노드가 Black, 형제 노드의 자식이 모두 Black
   - 형제 노드를 Red로 변경, 그러면 이 두 형제들을 가진 부모에서 블랙노드가 전체적으로 하나씩 모자라게 된다. 더 커진 트리에서 재귀적으로 해결한다.(이 부모의 형제 노드를 살펴본다.)
3. 형제 노드가 Black, 형제의 왼쪽 자식 - Red, 오른쪽 자식 - Black
   - 형제 노드를 Red로, 형제 노드를 기준으로 오른쪽으로 회전시킨다.
4. 형제 노드(S)가 Black, 형제의 왼쪽 자식 - Red/Black, 오른쪽 자식 - Red
   - 부모 노드(R)를 기준으로 왼쪽으로 회전 시킨다, R과 S의 색을 바꾼다. 원래 오른쪽 자식(Red였던)의 색을 Black으로 바꾼다.

### 참고자료(Red Black Tree)

- [Wiki - 레드-블랙 트리](https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC)
- [https://zeddios.tistory.com/237](https://zeddios.tistory.com/237)
