---
layout: single
title:  "쿠버네티스 개념 정리"
date:   2019-09-12 21:55:59 +0900
classes: wide
categories: etc
tags: kubernetes
toc: true
toc_sticky: true
---

## 쿠버네티스가 왜 필요한가

컨테이너는 애플리케이션을 포장하고 실행하는 좋은 방법이다. 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야한다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야한다. 이 문제를 시스템에 의해 처리한다면 더 쉽지 않을까?

쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공한다. 확장 요구 사항, 장애 조치, 배포 패턴 등을 처리한다. 예를 들어, 쿠버네티스는 시스템의 카나리아 배포를 쉽게 관리 할 수 있다.

쿠버네티스는 단순한 오케스트레이션 시스템이 아니다. 오케스트레이션의 기술적 정의는 A 먼저 한다음, B를 하고, C를 하는 것과 같이 정의된 workflow를 수행하는 것이다. 반면에, 쿠버네티스는 독립적이고 조합 가능한 제어 프로세스들로 구성되어 있다. 이 프로세스는 지속적으로 현재 상태를 입력받은 의도된 상태로 나아가도록 한다. A에서 C로 어떻게 갔는지는 상관 없다.

지원하는 애플리케이션의 유형을 제약하지 않는다. Stateless, Stateful workload 등 다양한 워크로드를 지원하는 것을 목표로 한다.

소스 코드를 배포하지 않으며, 애플리케이션을 빌드하지 않는다. CI/CD workflow는 팀취개취.

## 쿠버네티스까지 시간 흐름

![evolution](/assets/img/kubernetes/container_evolution.svg)

- 전통적인 배포 시대: 그림에서 보이는 것처럼 애플리케이션을 물리 서버에서 실행했었다. 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제가 발생했다. 한 물리 서버에 여러 애플리케이션을 띄워놓으면 A라는 애플리케이션이 리소스를 다 잡아먹어서 다른 B라는 애플리케이션은 성능이 저하될 수 있다. 그래서 서로 다른 물리서버에 A, B를 따로 띄우는 방법이 있는데, 이 경우는 서버의 하드웨어 리소스가 충분히 활용되지 않을 수 있어서 좋지 않다.(비용 문제도 크다.)
- 가상화된 배포 시대: 위 문제의 해결책으로 가상화를 사용했다. 단일 물리 서버의 CPU에서 여러 가상 시스템을 실행한다. 위 배포에서의 문제였던 하드웨어 리소스의 활용성이나 리소스 부족 문제를 충분히 해결할 수 있다.
- 컨테이너 개발 시대: 컨테이너는 VM과 유사하다. VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU, 메모리, 프로세스 공간 등이 있다. 기본 인프라와의 종속성을 끊었기 때문에, 클라우드나 OS 배포본에 모두 이식할 수 있다.

## 컨테이너의 장점

- 기민한 애플리케이션 생성과 배포
- 지속적인 개발, 통합 및 배포
- 개발과 운영의 관심사 분리
- OS수준의 정보와 Metric에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있다.
- 개발, 테스팅 및 운영 환경에 걸친 일관성
- 클라우드 및 OS 배포판 간 이식성
- 애플리케이션 중심 관리: OS의 논리적 자원을 사용하여 애플리케이션을 구동하는 수준으로 추상화 수준이 높아짐
- 느슨한 커플링, 분산되고, 유연하며, 자유로운 마이크로서비스
- 자원 격리: 애플리케이션 성능을 예측할 수 있다.
- 자원 사용량: 고효율 고집적

## 쿠버네티스가 제공하는 기능들

- 서비스 디스커버리와 로드 밸런싱: 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
- Storage Orchestration: 로컬 저장소, 공용 클라우드 공급자와 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다.
- 자동화된 롤아웃과 롤백: 배포된 컨테이너의 원하는 상태를 서술하고, 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 배포용 새 컨테이너를 만들고, 기존 컨테이너 제거, 모든 리소스를 새 컨테이너에 적용가능하다.
- 자동화된 bin packing: 각 컨테이너에 필요한 CPU 및 메모리의 양을 지정할 수 있다.
- 자동화된 복구: 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, 내가 지정한 상태검사(사용자 정의 상태검사)에 응하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그런 과정을 클라이언트에 보여주지 않는다.
- 시크릿과 구성관리: 암호, OAuth 토큰 및 ssh 키와 같은 중요한 정보를 저장하고 관리할 수 있다. 컨테이너 이미지 재구성하지 않고 스택 구성에 비밀을 노출하지 않고도 비밀 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.

## 참고자료

- [쿠버네티스](https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/)
