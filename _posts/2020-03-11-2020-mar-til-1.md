---
layout: post
title:  "TIL(3월)"
date:   2020-03-11 12:00:59 +0900
classes: wide
categories: etc
tags: web
---

**틀린 내용이나 본문의 내용과 다른 의견이 있으시면 댓글로 남겨주세요!**

## 03/13

### 암호화, HTTPS, MyISAM과 InnoDB

#### Hash, 단방향 암호화

평문을 암호문으로 바꾸는 것은 가능하지만, 암호문을 평문으로 복호화하는 것은 불가능한 방식

단순하게 생각하면 필요 없을 것 같지만, 비밀번호 같은 곳에 쓸 수 있다. SHA256 같은 기법들이 있다. 특정 입력값에 대해 똑같은 출력이 나온다. 해싱을 적용한다고 해서 보안상으로 완벽하진 않다. 결국에는 특정한 비트수로 변환이 되는 것이기 때문에, 입력값이 다르더라도 출력값이 같은 경우가 나올 수도 있다.

#### 양방향 암호화

암호화와 복호화가 모두 가능한 알고리즘이다. 대칭키와 비대칭키 방식으로 나누어지는데, 대칭키 방식은 암호화와 복호화에 동일한 키를 사용하고 비대칭키 방식은 암호화와 복호화에 다른 키를 사용한다. 비대칭키 방식은 공개키와 개인키를 가지고 암호화, 복호화를 한다. SSL에서 공개키 암호화 방식을 채택하고 있다. 송신하는 측은 수신하는 측의 공개키를 사용해서 암호화해서 보내고 이 암호문을 수신측에서는 자신의 비밀키를 사용해서 복호화한다. 공개키를 이용해서 암호화 한 것을 복호화 하는 것은 소인수 분해 문제의 해결 방법을 알아내는 것(NP문제를 해결하는 것이므로 불가능하다고 할 수 있다, 사실 이 소인수분해 문제를 해결한다면 이 세상에서 엄청나게 많이 사용하고 있는 암호화 알고리즘이 깨지는 것이기 때문에 엄청난 문제가 될 수 있다.)

#### HTTP vs. HTTPS

HTTP는, 평문 통신이기 때문에 도청 가능, 통신 상대를 확인하지 않기 때문에 위장 가능, 완전성을 증명할 수 없기 때문에 변조 가능 이라는 단점이 있다.

HTTPS = HTTP + 통신의 암호화 + 증명서 + 완전성 보호

처음 통신에서는 공개키 암호방식으로 공통키를 교환하고, 공통키 암호로 통신을 한다.

그러나 공통키가 중간에 바꿔치기 당했는지는 어떻게 증명 할까? -> 이를 위해서 인증 기관(CA: Certificate Authority)과 공개키 증명서가 이용되고 있다. 유명한 인증기관에는 VeriSign이 있다.

인증 기관은 다음과 같이 이용된다.

1. 서버의 운영자가 인증 기관에 공개키를 제출
2. 인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만든다.
3. 공개키 인증서에 서명이 끝난 공개키를 담는다.
4. 서버는 이 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신을 한다.
5. 공개키 인증서를 받은 클라이언트는 증명 기관의 공개키를 사용해서 서버의 공개키를 인증한 것이 CA라는 것과 서버의 공개키가 신뢰할 수 있다는 것을 알 수 있다.

#### MyISAM vs. InnoDB

MySQL 5.5.5 버전 이후로는 default engine이 InnoDB이다.

MyISAM | InnoDB
--- | ---
Foreign key 미지원 | Foreign key 지원
Full Text Search 지원 | MySQL 5.6 이후로는 Full Text Search 지원
Table 단위 lock | Row 단위 lock
Data Cache 미지원 | Data Cache 지원
Index Cache 지원 | Index Cache 지원
Clustered Index 미지원 | Clustered Index 지원
Transaction 미지원 | Transaction 지원

인터넷의 블로그에는 InnoDB가 Full Text Search 미지원이라고 나와있는데.. 일단 MySQL의 문서에는 5.6 버전 이후에는 지원한다고 나와있다.

참고 - 많은 인터넷의 블로그들과, [MySQL 문서 - MyISAM](https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html), [MySQL 문서 - InnoDB](https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html)

## 03/12

### Synchronous, Asynchronous I/O, Thread, Scheduling level

#### Synchronous

사용자 프로세스가 입출력 요청을 한 다음에 아무것도 못하고 기다리고 있다.

#### Asynchronous

입출력 요청 한 다음에 입출력 진행 되는 동안에 그 프로세스가 다음 instruction을 수행할 수 있다.

#### Thread

Process 내부에서 공유할 수 있는 건 다 공유하지만 CPU를 더 유용하게 쓰기 위해서 나누어진 단위라고 생각하면 편하다.

Program Counter, Register Set, Stack를 각각 가지고 있고, Code, Data, OS Resource를 Thread끼리 공유한다.

여러 쓰레드를 사용하면.. 하나의 쓰레드가 blocked 상태인 동안에도 동일 프로세스 내의 다른 쓰레드가 running 상태로 더 빠르게 처리할 수 있다. 병렬성을 높일 수 있다. 그러니까 큰 크기의 파일을 읽어오는 작업을 하고 있는 쓰레드가 있는 동안에도 다른 쓰레드는 다른 작업을 해서 성능 향상을 볼 수 있다.

#### Scheduling level

우리가 하루의 일정을 짜듯 resource들의 스케줄을 짠다고 생각하면 됨.

1. Long-term scheduling (Job scheduler)
   - 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정
   - 프로세스에 메모리(각종 자원들)를 주는 문제
   - 프로세스가 처음 생성 된 후(created) 메모리를 얻어 ready 상태로 보내는 것을 결정
   - degree of multiprogramming을 제어(메모리에 프로그램이 얼마나 올라갈지..)
   - time sharing system에는 보통 **없다.**(무조건 ready 상태로)
2. Short-term scheduling (CPU scheduler)
   - 어떤 프로세스를 다음번에 running 시킬지 결정
   - 프로세스에 CPU를 주는 문제
3. Medium-term scheduling
   - 여유 공간 마련을 위해서 프로세스를 통째로 메모리에서 디스크로 쫓아낸다.
   - 프로세스에게서 메모리를 뺏는 문제
   - degree of multiprogramming을 제어
   - 얘를 통해 memory를 뺏긴 애들이 suspended ready, suspended blocked 이런 상태로 넘어간다.

## 03/11

### Process

#### 프로세스의 Context

- CPU 수행 상태를 나타내는 hardware context
  - Program counter
  - 각종 register
- 프로세스의 주소 공간
  - Code, Data, Stack
- 프로세스 관련 커널 자료 구조
  - PCB
  - Kernel Stack

#### Process State

1. Running - CPU를 사용하고 있는 상태(Instruction을 수행중인 상태)
2. Ready - CPU를 기다리고 있는 상태(CPU를 제외한 모든 자원은 충족한 상태)
3. Blocked (wait, sleep) - CPU 자원이 있더라도 instruction을 수행할 수 없는 상태. I/O를 기다리고 있다거나.. (큰 파일을 읽을 때?)
4. Created - 프로세스가 생성중인 상태. (PCB 할당, 커널은 메모리가 여유있는지 확인하고 Ready나 Suspended Ready 상태로 바뀐다, Unix에서 fork()라는 시스템 콜에 의해 생성된다.)
5. Terminated - 수행이 끝난 상태

![Process State](/assets/img/til/process_state.png)

suspended 상태는 메모리에서 내려간 상태라고 생각하면 될듯(사용자가 프로그램을 일시정지, 시스템이 프로세스를 잠시 중단시키는 경우 등)

외부에서 다시 시작해주어야 Active 쪽으로 올라갈 수 있다. 반면에 Blocked 상태는 본인이 요청한 어떤 이벤트(I/O라던가..)가 완료되면 Ready 상태가 된다.

#### Context Switch

CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정, CPU가 다른 프로세스에게 넘어갈 때

1. CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
2. CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
