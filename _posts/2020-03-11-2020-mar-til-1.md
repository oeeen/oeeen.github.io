---
layout: post
title:  "TIL(3월)"
date:   2020-03-11 12:00:59 +0900
classes: wide
categories: etc
tags: web
---

**틀린 내용이나 본문의 내용과 다른 의견이 있으시면 댓글로 남겨주세요!**

## 03/14

### 데이터베이스

데이터베이스를 사용하는 이유 - 파일 시스템을 사용했던 것의 한계를 극복하기 위해

장점 - 데이터 독립성, 무결성, 보안성, 일관성, 중복 최소화

#### 데이터베이스 인덱스

인덱스는 데이터베이스에서 테이블에 대한 동작 속도를 높여주는 자료구조이다. 테이블 내의 1개 이상의 컬럼을 이용해서 생성할 수 있다. 특정 데이터를 검색하기 위해서 테이블의 레코드를 풀스캔하는 것이 아니라, 인덱스가 적용된 컬럼의 테이블을 따로 파일로 저장해놓고 그 파일을 검색한다.

InnoDB에서는 항상 clustered index를 가져야함(PK는 항상 clustered index, unique index로 정의된 컬럼 중 하나, 보이지 않는 컬럼을 내부적으로 추가하여 사용)

Clustered Index - 인덱스를 매칭시키기 위해서 데이터 블럭을 분명한 순서로 바꾼다. Clustered index는 read 속도를 향상 시킨다.

Non-Clustered Index - 데이터는 임의의 순서, 논리적 순서는 인덱스에 의해 지정됨. row의 물리적 순서는 인덱스 순서와 동일하지 않다.

DBMS 의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 사용하지 않는 인덱스는 제거하자. 카디널리티가 높은 칼럼에 인덱스를 생성해주는 것이 좋다. 흔히 사용하는 인덱스는 B-tree 인덱스다.

인덱스가 생성되면 테이블과 매핑된 또다른 테이블이 생성된다고 생각하면 좋다. 인덱스 컬럼을 기준으로 sorting되어 저장된다. 특정 조건에 대해 검색을 한다고 하면 시작점을 지정해서 거기서부터 스캔(Index Range Scan)을 할 수 있다고 생각하면 됨. 인덱스에서 먼저 데이터를 찾고 그 테이블로 매핑된 곳을 가서 나머지 데이터들을 꺼내오는 방식. 인덱스가 해당 테이블 블럭의 주소를 가지고 있다고 생각하면 된다.

Where절에 자주 등장하는 컬럼, Order By절에 자주 등장하는 컬럼을 인덱스로 구성하면 좋다. 그렇다고 마구잡이로 인덱스를 생성하면 안된다. 테이블이 가지고 있는 전체 데이터 양의 10에서 15프로 일때 효율적이고 그 이상일 떈 풀스캔이 더 빠르다.(?)

## 03/13

### 암호화, HTTPS, MyISAM과 InnoDB

#### Hash, 단방향 암호화

평문을 암호문으로 바꾸는 것은 가능하지만, 암호문을 평문으로 복호화하는 것은 불가능한 방식

단순하게 생각하면 필요 없을 것 같지만, 비밀번호 같은 곳에 쓸 수 있다. SHA256 같은 기법들이 있다. 특정 입력값에 대해 똑같은 출력이 나온다. 해싱을 적용한다고 해서 보안상으로 완벽하진 않다. 결국에는 특정한 비트수로 변환이 되는 것이기 때문에, 입력값이 다르더라도 출력값이 같은 경우가 나올 수도 있다.

#### 양방향 암호화

암호화와 복호화가 모두 가능한 알고리즘이다. 대칭키와 비대칭키 방식으로 나누어지는데, 대칭키 방식은 암호화와 복호화에 동일한 키를 사용하고 비대칭키 방식은 암호화와 복호화에 다른 키를 사용한다. 비대칭키 방식은 공개키와 개인키를 가지고 암호화, 복호화를 한다. SSL에서 공개키 암호화 방식을 채택하고 있다. 송신하는 측은 수신하는 측의 공개키를 사용해서 암호화해서 보내고 이 암호문을 수신측에서는 자신의 비밀키를 사용해서 복호화한다. 공개키를 이용해서 암호화 한 것을 복호화 하는 것은 소인수 분해 문제의 해결 방법을 알아내는 것(NP문제를 해결하는 것이므로 불가능하다고 할 수 있다, 사실 이 소인수분해 문제를 해결한다면 이 세상에서 엄청나게 많이 사용하고 있는 암호화 알고리즘이 깨지는 것이기 때문에 엄청난 문제가 될 수 있다.)

#### HTTP vs. HTTPS

HTTP는, 평문 통신이기 때문에 도청 가능, 통신 상대를 확인하지 않기 때문에 위장 가능, 완전성을 증명할 수 없기 때문에 변조 가능 이라는 단점이 있다.

HTTPS = HTTP + 통신의 암호화 + 증명서 + 완전성 보호

처음 통신에서는 공개키 암호방식으로 공통키를 교환하고, 공통키 암호로 통신을 한다.

그러나 공통키가 중간에 바꿔치기 당했는지는 어떻게 증명 할까? -> 이를 위해서 인증 기관(CA: Certificate Authority)과 공개키 증명서가 이용되고 있다. 유명한 인증기관에는 VeriSign이 있다.

인증 기관은 다음과 같이 이용된다.

1. 서버의 운영자가 인증 기관에 공개키를 제출
2. 인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만든다.
3. 공개키 인증서에 서명이 끝난 공개키를 담는다.
4. 서버는 이 공개키 인증서를 클라이언트에 보내고 공개키 암호로 통신을 한다.
5. 공개키 인증서를 받은 클라이언트는 증명 기관의 공개키를 사용해서 서버의 공개키를 인증한 것이 CA라는 것과 서버의 공개키가 신뢰할 수 있다는 것을 알 수 있다.

#### MyISAM vs. InnoDB

MySQL 5.5.5 버전 이후로는 default engine이 InnoDB이다.

MyISAM | InnoDB
--- | ---
Foreign key 미지원 | Foreign key 지원
Full Text Search 지원 | MySQL 5.6 이후로는 Full Text Search 지원
Table 단위 lock | Row 단위 lock
Data Cache 미지원 | Data Cache 지원
Index Cache 지원 | Index Cache 지원
Clustered Index 미지원 | Clustered Index 지원
Transaction 미지원 | Transaction 지원

인터넷의 블로그에는 InnoDB가 Full Text Search 미지원이라고 나와있는데.. 일단 MySQL의 문서에는 5.6 버전 이후에는 지원한다고 나와있다.

참고 - 많은 인터넷의 블로그들과, [MySQL 문서 - MyISAM](https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html), [MySQL 문서 - InnoDB](https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html)

## 03/12

### Synchronous, Asynchronous I/O, Thread, Scheduling level

#### Synchronous

사용자 프로세스가 입출력 요청을 한 다음에 아무것도 못하고 기다리고 있다.

#### Asynchronous

입출력 요청 한 다음에 입출력 진행 되는 동안에 그 프로세스가 다음 instruction을 수행할 수 있다.

#### Thread

Process 내부에서 공유할 수 있는 건 다 공유하지만 CPU를 더 유용하게 쓰기 위해서 나누어진 단위라고 생각하면 편하다.

Program Counter, Register Set, Stack를 각각 가지고 있고, Code, Data, OS Resource를 Thread끼리 공유한다.

여러 쓰레드를 사용하면.. 하나의 쓰레드가 blocked 상태인 동안에도 동일 프로세스 내의 다른 쓰레드가 running 상태로 더 빠르게 처리할 수 있다. 병렬성을 높일 수 있다. 그러니까 큰 크기의 파일을 읽어오는 작업을 하고 있는 쓰레드가 있는 동안에도 다른 쓰레드는 다른 작업을 해서 성능 향상을 볼 수 있다.

#### Scheduling level

우리가 하루의 일정을 짜듯 resource들의 스케줄을 짠다고 생각하면 됨.

1. Long-term scheduling (Job scheduler)
   - 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정
   - 프로세스에 메모리(각종 자원들)를 주는 문제
   - 프로세스가 처음 생성 된 후(created) 메모리를 얻어 ready 상태로 보내는 것을 결정
   - degree of multiprogramming을 제어(메모리에 프로그램이 얼마나 올라갈지..)
   - time sharing system에는 보통 **없다.**(무조건 ready 상태로)
2. Short-term scheduling (CPU scheduler)
   - 어떤 프로세스를 다음번에 running 시킬지 결정
   - 프로세스에 CPU를 주는 문제
3. Medium-term scheduling
   - 여유 공간 마련을 위해서 프로세스를 통째로 메모리에서 디스크로 쫓아낸다.
   - 프로세스에게서 메모리를 뺏는 문제
   - degree of multiprogramming을 제어
   - 얘를 통해 memory를 뺏긴 애들이 suspended ready, suspended blocked 이런 상태로 넘어간다.

## 03/11

### Process

#### 프로세스의 Context

- CPU 수행 상태를 나타내는 hardware context
  - Program counter
  - 각종 register
- 프로세스의 주소 공간
  - Code, Data, Stack
- 프로세스 관련 커널 자료 구조
  - PCB
  - Kernel Stack

#### Process State

1. Running - CPU를 사용하고 있는 상태(Instruction을 수행중인 상태)
2. Ready - CPU를 기다리고 있는 상태(CPU를 제외한 모든 자원은 충족한 상태)
3. Blocked (wait, sleep) - CPU 자원이 있더라도 instruction을 수행할 수 없는 상태. I/O를 기다리고 있다거나.. (큰 파일을 읽을 때?)
4. Created - 프로세스가 생성중인 상태. (PCB 할당, 커널은 메모리가 여유있는지 확인하고 Ready나 Suspended Ready 상태로 바뀐다, Unix에서 fork()라는 시스템 콜에 의해 생성된다.)
5. Terminated - 수행이 끝난 상태

![Process State](/assets/img/til/process_state.png)

suspended 상태는 메모리에서 내려간 상태라고 생각하면 될듯(사용자가 프로그램을 일시정지, 시스템이 프로세스를 잠시 중단시키는 경우 등)

외부에서 다시 시작해주어야 Active 쪽으로 올라갈 수 있다. 반면에 Blocked 상태는 본인이 요청한 어떤 이벤트(I/O라던가..)가 완료되면 Ready 상태가 된다.

#### Context Switch

CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정, CPU가 다른 프로세스에게 넘어갈 때

1. CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장
2. CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어옴
